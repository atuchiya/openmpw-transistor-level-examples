# Test Bench Collection for Xschem

テストベンチ (test bench) とは，ある回路の性能を評価するために評価対象回路の周辺に接続する回路のことです．
入力の信号源，出力負荷，電源，制御信号などが含まれます．テストベンチは評価対象回路に接続されている回路をモデル化したものですが，どのような特性を評価したいかによって使い分ける必要があります．テストベンチの構成や設定は意外にミスをしやすいので，典型的な構成をサンプルとして作りました．対応する .measure 文なども含むので，このサンプルを自分の回路に合わせて調整して使ってください．

通常，評価対象の回路は1つのシンボルとしておき，それにテストベンチを接続する形を取ります (`dc_03` 以降の形)．そうしなければならないというわけではありませんが，
* アナログ回路では1つの回路に対して複数のテストベンチを用いた評価を行なうことが多いため，評価対象の回路を再利用しやすいシンボルにしておく方が便利
* 実際に集積回路に搭載するのは評価回路のみで，テストベンチは含まない．LVSなどの検証工程のためにテストベンチを含まない回路図 (スケマティック) がないと困る
などの理由により，評価対象の回路とテストベンチは分けておきます．

## 1. DC解析

### 基本的な DC 解析 (`dc_01`)

DC解析の結果をプロットする基本的な構成です．ここでは M1，R1 からなるソース接地増幅回路が評価対象回路，入力 `Vin`，電源 `Vdd`，グラウンド がテスト用の回路です．
シミュレータの制御を行なっているのが `control` カードで，
* `.options savecurrent` で電流も記録
* `save all` ですべてのノードのデータを記録
* `save @M1[gm]` でトランジスタ M1 の gm を記録
* `dc` で DC解析の指示 (`.control` の中なので `.dc` でなく`dc` なことに注意)
* `plot` で各種グラフを表示

また，`.measure` を使って特定の条件の値を抽出しています．この例では
`.measure dc half when V(out)=0.9` なので「DC解析において，V(out) が 0.9 V になる入力 (Vin) の値を half という名前で表示せよ」
となります．結果は ngspice のターミナルに表示されます．

### パラメータの使い方 (`dc_02`)

回路の評価では条件をいろいろ変えながら行なうのが普通です．そのため，変更される値はパラメータにしておきましょう．パラメータの定義には `.param` を使います．
`.param vdd=1.8` でパラメータ vdd を 1.8 と定義ています．電源電圧 `Vdd` の値が `dc_01` では 1.8 だったのが `vdd`に，`.measure` の条件が 0.9 から `'vdd / 2'` に変わっています．これにより，電源電圧が変動した場合の評価を行なうときも `.param` の vdd を書き換えるだけで電源電圧の変動に対応した条件で評価を行なうことができます．

また，`.measure` のところで使っているように，`.param` で定義したパラメータは演算を行なうことが可能です．この例では電源電圧の半分を表すために `'vdd / 2'` と書いています．**シングルクォーテーションで囲まれている**ことに注意してください．演算を行なうときには必ずシングルクォーテーションで囲む必要があります．ちなみに，このパラメータの演算に関する書式はシミュレータによって微妙に違うことがあります．少なくとも ngspice と hspice は違います．

### サブサーキットの使い方 (`dc_03`)

この例は評価対象回路がシンボル (サブサーキット) になっています．やっていることは `dc_02` と同じですが，ここではサブサーキット内の値にアクセスする方法を覚えてください．
control カード内で，gm を取得している部分です．同一回路内にトランジスタ (M1) がある場合は `dc_01` の例での説明したように `@M1[gm]` と，素子名の前に `@`，後ろに取得したいパラメータを大括弧で囲むことで値を取得できます．これがサブサーキットになっている場合，`.` を使って階層を下りていくことができます．
つまり，サブサーキット `X1` の中で `M1` という名前をもっている素子には `X1.M1` でアクセスできます．素子のパラメータにアクセスする場合，先頭の`@` の後ろには **アクセスしようとしている素子の種別** が来まる．ここでは，MOS FET を表す `M` が来て，`@M.X1.M1[gm]` となります．`@X1.M1[gm]` ではないので注意してください．

## 2. AC解析

### 周波数特性と動作点 (`ac_01`)

AC解析，と言いながらここでは AC解析と OP解析をやっています．そのため `control`カード がちょっと長くなっています．

まずは OP解析で消費電力を求めます．トランジスタに流れる電流を取得する方法と，電源から流れ出る電流を取得する方法の2通りをやっています．普通は電源から流れ出る電流を取ります．

* `op` で OP解析を実施
* `let id=@M.X1.M1[id]` でトランジスタのドレイン電流を取得し，`id` に代入
* `let isupply=-i(vdd)` で電源 (Vdd) から流れ出る電流を取得し，`isupply` に代入
* `print 'id * vdd'` でドレイン電流×電源電圧を計算し，ターミナルに表示
* `print 'isupply * vdd'` で電源から流れ出る電流×電源電圧を計算し，ターミナルに表示

当然ながら両方同じ値になります．

次に AC解析です．

* `ac dec 20 10k 10G` で 10 kHz から 10 GHz まで解析を実施
* `plot` で結果をプロット
  * `V(out)` は振幅の値がそのまま出ます．反転増幅なので負の値がでます．**これはAC解析における話であり，実際に出力電圧が負の値になるわけではありません．**
  * `Vdb(out)` は振幅のデシベル値 (20log10(V) )
  * `Vp(out)` は位相 (Phase)

次に，`.measure` で重要な値を取得します．AC解析でよく使うのは，「特定の周波数の値を取得する find」と「条件を満たす周波数を取得する when」の2つです．
* `find` の例として，直流 (解析範囲で最も低い周波数) での利得を 'Gdc' で取得
* `when` の例として，-3dB帯域と UGF (単位利得周波数) をそれぞれ BW，UGF で取得
しています．


***BW の条件，`when Vdb(out) = 'Gdc - 3'` と書きたいんですが ngspice だとこれが使えません．hspice ならこの書き方ができるのに．ngspice でのやり方誰か教えてください***

## 3. Tran解析

### 入力の種類 (`tran_01`)

過渡解析では入力の波形を作る必要があります．基本的なものとして，繰り返しパルス `pulse`，正弦波 `sin`，折れ線 `pwl` (piece-wise linear) を示しています．書式の詳細はマニュアルを見てください．

* `pulse (v1 v2 td tr tf pw period N)` 初期電圧 v1，パルス電圧 v2，遅延時間 td，立ち上がり時間 tr，立ち下がり時間 tf，パルス幅 pw，パルス周期 period，パルス数 N
* `sin (offset amplitude freq)` 中心電圧 offset，振幅 amplitude，周波数 freq
* `pwl (t1 v1 t2 v2 t3 v3 ....)` 時刻 t1 での電圧 v1，時刻 t2 での電圧 v2，…

### .measure (`tran_02`)

Tran解析での `.measure` は時間を測るものと電圧を測るものがあります．時間を測る場合，「開始条件を満たしてから終了条件を満たすまで」を計測するため，
書式はちょっと複雑です．例えば

`.measure tran tfall trig v(out) val='vdd * 0.8' fall=1 targ v(out) val='vdd * 0.2' fall=1`
ですが，大きく分けて開始条件 `trig` (trigger)，終了条件 `targ` (target) から成ります．そのそれぞれについて，「どこの電圧がどの値に何回目になったときか」の形式で指定します．
この例では「`v(out)` が電源電圧の80%を下向きに1回目に横切ったとき」がトリガーで，「`v(out)`が電源電圧の20%を下向きに1回目に横切ったとき」がターゲットで，立ち下がり時間を計測しています．
同じように，`trise` が立ち上がり時間，`delay_rise` が立ち上がり時の伝搬遅延時間，`delay_fall` が立ち下がり時の伝搬遅延時間です．

一方，電圧を測る場合は比較的簡単です．例えば電圧の最大値は `max`，最小値は `min` です．(`from` と `to` で時間の範囲を指定し，「ある時間の中での最大値」などを取ることもできます)．

また，この例では消費電力 (正確には消費エネルギー) も計算しています．Tran解析では流れる電流が一定ではないため積分が必要になりますが，ngspice には積分が組み込まれていますので
`plot 'vdd * integ(-i(Vdd))'` で電源電圧×電流の積分を求めることができます．


### (おまけ) power-meter (`tran_03`)

`tran_02` で示したように，ngspice には積分が組み込まれているので電力の計算には積分関数を使います．しかし，積分の関数がなくても積分はできます．
Berkeley SPICE で積分が使えなかった頃に編み出されたのが `tran_03` の Power Meter です．原理は簡単で，電流制御電流源 (CCCS) `Fpm` で電源に流れる電流をコピーし，それをキャパシタ (積分器) に溜めていきます．
(初期電荷を0にしておく必要があるため，`.ic V(pm)=0` を追加して初期値を指定しています．)
キャパシタの電位差が積分結果になります．この例では Fpm の倍率を電源電圧の 1.8 に設定することで，電位差の数字をそのまま電力として読み取れるように設定しています．`integ` のグラフと `V(pm)` を比較してください．

なお，キャパシタの横の抵抗はシミュレーションのエラーを回避するためのもので，非現実的に巨大な値 (1 GΩ) に設定されています．
(直流の経路が存在しない回路はよくエラー "no dc path to ground" などを起こす．)


